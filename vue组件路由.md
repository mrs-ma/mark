# 组件component

组件是拥有一定功能许多html标签的集合体，是对html标签的封装

```
new Vue({
  components:{
    '组件的名称': { 配置对象成员 }, 
    '组件的名称': { 配置对象成员 }...
  },
})
```

<组件名称></组件名称>

可以认为**组件**是特殊的**Vue实例**，拥有着与Vue实例大致相同的**成员**

例如  **data**、**methods**、**filters**、**directives**、**created**等等成员在组件内部都可以设置

组件data成员 与 Vue实例的 不一样，需要通过 function/return 设置，具体要返回一个{}对象

`组件 与 Vue实例 异同`：

1. 组件中的 data 必须是一个 **function** 并 return 一个 字面量对象
   (Vue 实例的 data 可以是 字面量对象，也可以是 function/return形式，前者推荐使用)
2. 组件中直接通过 template 属性来指定组件的html结构
   Vue 实例中，一般通过 el 属性来指定渲染的容器，当然也可以使用template
3. 组件和Vue实例拥有类似的成员，都有自己的生命周期函数，过滤器，methods、data等成员

# VueCLI

是脚手架，其可以把许多项目**通用的依赖包**(vue、webpack、路由、vuex、less编译器等等) 和 **通用的配置**都给做好安装好，使得开发者全部的注意力都集中在业务层面，明显提升开发效率的，真实项目都要使用脚手架开发。

`安装vuecli`：

npm i -g @vue/cli   // 使用该方式安装

`vuecli创建项目`：

vue  create  项目名称(01-pro)

# ES6模块化

项目中一些**程序代码**经常被其他业务场景使用，为了避免重复开发，就把这些代码设置为**共享模式**，共享模式就是**模块化**。像jquery、axios、vue等等都是模块化的体现，需要的时候直接拿过来用即可 

`模块化技术有哪些`：

CommonJS(nodejs)、ES6模块化、AMD、CMD等

`CommonJS`：

```
// 导出
module.exports = 对象
// 导入
var obj = require(模块文件)
```

`ES6模块化`：

ES6模块化 是**2015**年**官方正式出品**的，已经被纳入到JavaScript标准里边，也是js未来的标准，由于各种原因 nodejs和浏览器中现在还不能直接使用ES6模块化，要相信未来可以

## 默认导出和导入

在一个js文件中，通过一个**对象**把全部的数据导出出去，就是**默认导出**

对默认导出的成员进行接收就是默认导入

一个js文件就是一个模块，前提是该文件有做**导出**动作

```
// 导出：
export default  对象
```

```
// 导入：
import 名称  from  模块文件名字
```

## 按需导出和导入

一个js模块中，定义了N多的成员信息，根据需要，用哪个就导出哪个，这就是按需

`导出语法`

```
export const  a = 10		// 常量
export function ab(){}  // 函数
export const  b = 20
export const cat = {name:'kitty',age:5} // 对象
...
```

`导入语法`：

```
import {xx,yy,zz} from 模块文件
import {xx as kk,yy as mm,zz as qq} from 模块文件     // 根据需要可以设置别名
```

`导入语法`：

```
// 1) 分别导入import 名称  from  模块import  {xx,yy}  from  模块// 
   2) 一并导入import 名称,{xx,yy} from 模块
   一并导入必须是 默认在"前"，按需在"后"
```

## 没有导出应用

项目开发时有的文件没有做导出动作(例如 css、less)，这样文件可以称为为 非模块文件，那么可以通过如下方式做导入     

```
import  文件路径名
```

# 单文件组件 

把一个组件的全部内容汇合到**一个文件**中，文件名字是以`.vue`结尾的就称作**vue单文件组件**

1. 单文件组件，每个组件都有3个部分（template/script/style）
2. template 是固定标签，内部要求有**唯一根元素**
3. script  导出一个对象     对象成员可以参考Vue实例
4. style 设置样式
5. 组件需要被main.js文件 引入、注册，之后index.html应用

## scoped属性

默认情况下，vue单文件组件的style样式是[全局的]()，

如果在一个应用中使用了**多个**单文件组件，它们使用<span style="background-color:yellow;">相同选择器</span>为相同的元素设置了style样式，那么只有一个会起作用 (后者会覆盖前者)

`scoped作用`：

使得style的样式针对自己组件生效

`原理`：

​	给每个style标签都设置一个`scoped`属性，这样组件的各个html标签解析出来后都会带有一个与其他单组件标签不同的 <font color=red>data-v-xxx</font> 的唯一属性名称，style样式设定也会自动与这个的data-v-xxx联系起来，这样就使得style样式只针对自己的组件起作用了

## 父子嵌套组件应用

`嵌套本质`：

​	一个单文件组件可以  **引入**、**注册**、**使用** 另外一个单文件组件

## 父给子传值

`语法`：

父组件要在子组件标签上通过**属性值**方式传值

<子组件标签 name=value name=value name=value></子组件标签>

<input :style="{color:xx}">

<script>
  export default {
    // 通过props接收父传递过来的数据,注意各个名称需要使用单引号圈选
    props:['xx','xx','xx']
  }
</script>

# render方法扩展使用

```
new Vue({
  render:h=>h('p','ok')  // 要生成 <p>ok</p> 并覆盖渲染 div容器
  render:h=>h(组件模块) // 要使用一个组件模块 对 div容器 进行覆盖渲染
})
```

# SPA

单页面应用程序项目：一个网站只有一个Web页面；网站的所有功能都在这个唯一的页面上进行展示与使用

`好处`：

1. 实现了前后端**分离模式**(目前最好的开发模式)开发，各司其职；提高了开发效率；
2. 用户体验好，页面部分内容发生变化只需要更新局部即可(非刷新整个页面)；

`缺点`：

1. 对SEO(搜索引擎)不是很友好，网站从开始到结束始终访问一个程序文件，造成搜索引擎不给检索， 但是有解决方案，再者后台系统应用本身对seo不做要求

   (ssr处理seo阅读了解： https://www.jianshu.com/p/fcb98533bc18?tdsourcetag=s_pctim_aiomsg )

2. 每次应用运行时，需要一次性把全部的html、js、css等内容加载进来，因此会造成页面一开始请求速度较慢的问题(首页较慢，后续页面正常)

# 路由

路由是一个js功能模块，用于解决SPA项目组件切换显示问题的，本身对**组件切换**的各个底层技术有做**封装**，是更成熟组件切换解决方案，使用起来更高级、方便。

## 安装

安装路由两种方式：

1. vuecli创建项目的时候(勾选Router项目即可，这是会增加一个步骤，选择n即可)
2. 单独安装                    npm i vue-router

## 具体配置

在`src/main.js`中给路由做如下配置：

1. import引入 路由
2. import引入 各个业务组件模块
3. Vue.use(路由模块) 注册路由组件
4. 创建路由对象，通过path、component设置#锚点 与 组件的联系
5. 在Vue实例内部 挂载 router路由对象

## 设置切换按钮和占位符

```
<router-link to="/home">首页</router-link>
通过router-link设置  按钮和#锚点信息
```

```
<router-view></router-view>
通过 router-view 设置组件显示占位符
```

## 重定向

用户第一次访问网站页面("/根目录"首页)时，地址栏里边没有“#锚点”的信息，
也就没有对应的组件用于显示，用户体验不好，现在可以通过重定向实现一种效果，即当浏览器没有任何 #锚点信息时，我们默认也给显示一个组件

重定向：使得一个路由地址A与另一个路由地址B联系起来，执行A的时候会跳转执行B

```
var router = new VueRouter({
  routes:[
    // {path:'/', redirect:'跳转到的路由地址'}
    {path:'/', redirect:'/home'},
    {path:'/home', component:Home},
    ……
  ]
})
```

## 子路由

一般项目开发中，App.vue是根基组件(第1级别的)，内部可以有具体业务组件Home.vue  Movie.vue  Music.vue，它们是第2级别，根据业务需要，业务组件内部还要做内容**分级**显示，例如音乐Music.vue下边要求显示 香港音乐/台湾音乐/大陆音乐等，它们是第3级别组件

第3级别组件做应用的时候需要设置路由，并且与第2级别组件路由有形成父子关系，故称为  子路由

注：

1. 要通过 children 关键字设置子路由
2. 第三级别组件对应的  切换按钮(router-link) 和 显示占位符(router-view)  需要在Music.vue组件中设置

3. 第二级别组件对应的 切换按钮(router-link)  和 显示占位符(router-view)  需要在App.vue组件中设置

## 路由传参

项目中有应用场景是这样的：

商品列表页面中，每个商品项目都有 详情页面，为了知道哪个商品被展示查看需要在路由地址中额外设置商品的数字id信息(如下图)，以便据此查询商品，这个商品id就是“**路由传参**”

`接收路由参数`：

```
<标签>{{$route.params.xxx}}</标签>
<script>
new Vue({
  created(){
    this.$route.params.xxx
  }
	
})
</script>
```

## 编程式导航

一个路由被执行一次，就是一次导航

`导航种类`：

1. **声明式导航**：router-link可以编译生成超链接按钮，单击按钮就切换路由并显示对应的组件，这个过程称为“声明式导航(静态)”
2. **编程式导航**：有时由于业务需要，一个路由被切换执行并不方便通过**声明式导航**实现，相反是要通过**程序代码**的方式给实现出来，就是“编程式导航(动态)”



`编程式导航的实现`：

```
路由对象.push(路由地址)   // 根据路由地址执行到昂  最经常使用********
路由对象.back()  				// 后退************
路由对象.forward()  		// 前进
路由对象.go(数字整数)    // 根据“整型数字”参数做路由的 前进(大于0)、刷新(等于0)、后退(小于0) 操作

```

`路由对象`：

1. main.js中，就是**router**
2. 在组件实例中 就是 **this.$router**

## 守卫

每个路由在执行的时候都会经历一些"**关口**"，关口可以做决定是否 继续前进 或 执行其他路由 或 停止当前路由执行 ，关口就是守卫

`语法`：

```js
router.beforeEach((to, from, next) => { /* 导航守卫 处理逻辑 */ })
```

# WebStorage

WebStorage是浏览器中存储信息的技术，是HTML5为克服cookie的缺陷而发布的

`cookie缺陷`：

1. 大小受限，单个项目有**4k**限制 abcd=4个字节   1024个字节=1k  1024k=1MB
2. 用户可以操作（禁用）cookie，使功能受限
3. 每次请求时，cookie都会存放在请求头中，请求被拦截，cookie数据会存在**安全**隐患

`WebStorage特点`：

1. 存储空间更大，单个项目 Chrome，Firefox和Opera 数据大小可以达到 **5MB**， IE是10M 
2. 只能存储**字符串**类型
3. 不能被爬虫抓取到，更安全 

WebStorage的使用具体分为两种：localStorage（持久存储） 和 sessionStorage（会话存储）



